##### 一、选择排序：
交换次数最小的排序
交换消耗大的可以用选择排序
##### 二、插入排序：
- 优化点一：如何不交换插入排序，常数项可以减低到2n2
- 遇到近乎有序的数组，插入排序接近O(n)的性能
- n比较小时，插入排序比O(nlgn)的排序更加有效，因为常数项很小
- 思考用二分查找法做插入排序：数据交换空间没有减小，面对近乎有序的数据也没什么用，所以实践比较少
##### 三、归并排序：
- 稳定的排序算法
- 优化一：数据量少的时候，可以用插入排序
- 优化二：什么时候不需要merge？左半部分最大的值小于右半部分最小的值的时候，不需要交换
- 优化三：减少辅助空间的分配和使用
- 实现自底向上的规定排序
- java底层List实现排序用的是就是归并排序，小数据量时用插入排序
##### 四、快速排序：
- 优化一：面对近乎有序的数组，随机选取标定点
- 面对近乎相同的数据，随机快排也会退化为O(n2)的算法
- 优化二：双路快排
- 优化三：三路快排，非常优秀的算法，在近乎相同的数据中可以得到O(n)的，jdk8底层实现用的双路快排
定义好这个范围，也就是循环不变量，才能好好面对这种问题
<code>int lt = l;//[l+1,lt]<p</code>
<code>int i = l+1;//[lt+1,i-1]==p</code>
<code>int gt = r+1;//[gt,r]>p</code>
##### 五、堆排序：
##### 六、Fisher-Yates洗牌算法：
##### 七、FloodFill应用在抠图上面：