##### 一、生成唯一ID要求：
- 1、全局唯一性：不能出现重复的id号（基本的要求）
- 2、信息安全：防止恶意用户根据id的规则来获取数据
- 3、数据递增：保证下一个ID一定大于上一个ID
	- 互斥关系：信息安全、数据递增规律
##### 二、业界方法：
- 1、UUID：
	- 通用唯一识别码16个字节128为的长数字（UUID.randomUUID().toString()）
	- 组成部分：当前日期和时间序列+全局的唯一性网卡mac地址
	- 案例：
		- 执行任务数：10000
		- 所有线程共耗时：38.481s
		- 并发执行完成耗时：439.0ms
		- 单任务平均耗时：3.8481ms
		- 单线程最小耗时：0.0ms
		- 单线程最大耗时：178.0ms
	- 优点：代码实现简单、不占用宽带、数据迁移不受影响
	- 缺点：无序、无法保证趋势递增（要求3）字符存储、传输查询慢、不可读
- 2、Snowflake雪花算法
	- 国外的twitter分布式下ID生成算法：
	- 1bit+41bit+10bit+10bit=62bit
	- 高位随机+毫秒数+机器码（数据中心+机器id）+10的流水号
	- 国内：保证数据的唯一性就行了 IDC机房
	- 优点：代码实现简单、不占用宽带、数据迁移不受影响、地位趋势递增
	- 确定：强依赖时钟（多台服务器的时间一定要一样）无序无法保证递增趋势（要求3）
- 3、mysql方案：
	- 优点：代码实现方便、性能不错、数字排序、可读性很强
	- 缺点：受限数据库、扩展麻烦、插入数据库才能拿到ID、单点故障问题
	- 主从同步的时候：电商下单--->支付insert master db select 数据，因为数据同步延迟导致查不到这个数据。家cache(不是最好的解决方式)数据要求比较严谨的话查master主库
- 4、Redis：
	- 缩减版本、有关业务代码没有包含到里头、redis方案
	- 年份+当前这天数据这一年的第多少天+小时+redis自增（2+3+2+5=12位）
	- 优点：不依赖数据库、灵活方便、新更能优于数据库的、没有单点故障（高可用）
	- 缺点：需要占用网络资源、性能比本地生成慢、需要增加插件